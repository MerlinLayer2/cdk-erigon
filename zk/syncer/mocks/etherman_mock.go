// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/erigontech/erigon/zk/syncer (interfaces: IEtherman)
//
// Generated by this command:
//
//	mockgen -typed=true -destination=./mocks/etherman_mock.go -package=mocks . IEtherman
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	big "math/big"
	reflect "reflect"

	ethereum "github.com/erigontech/erigon"
	common "github.com/erigontech/erigon-lib/common"
	types "github.com/erigontech/erigon/core/types"
	gomock "go.uber.org/mock/gomock"
)

// MockIEtherman is a mock of IEtherman interface.
type MockIEtherman struct {
	ctrl     *gomock.Controller
	recorder *MockIEthermanMockRecorder
	isgomock struct{}
}

// MockIEthermanMockRecorder is the mock recorder for MockIEtherman.
type MockIEthermanMockRecorder struct {
	mock *MockIEtherman
}

// NewMockIEtherman creates a new mock instance.
func NewMockIEtherman(ctrl *gomock.Controller) *MockIEtherman {
	mock := &MockIEtherman{ctrl: ctrl}
	mock.recorder = &MockIEthermanMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIEtherman) EXPECT() *MockIEthermanMockRecorder {
	return m.recorder
}

// BlockByNumber mocks base method.
func (m *MockIEtherman) BlockByNumber(ctx context.Context, blockNumber *big.Int) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BlockByNumber", ctx, blockNumber)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BlockByNumber indicates an expected call of BlockByNumber.
func (mr *MockIEthermanMockRecorder) BlockByNumber(ctx, blockNumber any) *MockIEthermanBlockByNumberCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlockByNumber", reflect.TypeOf((*MockIEtherman)(nil).BlockByNumber), ctx, blockNumber)
	return &MockIEthermanBlockByNumberCall{Call: call}
}

// MockIEthermanBlockByNumberCall wrap *gomock.Call
type MockIEthermanBlockByNumberCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanBlockByNumberCall) Return(arg0 *types.Block, arg1 error) *MockIEthermanBlockByNumberCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanBlockByNumberCall) Do(f func(context.Context, *big.Int) (*types.Block, error)) *MockIEthermanBlockByNumberCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanBlockByNumberCall) DoAndReturn(f func(context.Context, *big.Int) (*types.Block, error)) *MockIEthermanBlockByNumberCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CallContract mocks base method.
func (m *MockIEtherman) CallContract(ctx context.Context, msg ethereum.CallMsg, blockNumber *big.Int) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CallContract", ctx, msg, blockNumber)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CallContract indicates an expected call of CallContract.
func (mr *MockIEthermanMockRecorder) CallContract(ctx, msg, blockNumber any) *MockIEthermanCallContractCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CallContract", reflect.TypeOf((*MockIEtherman)(nil).CallContract), ctx, msg, blockNumber)
	return &MockIEthermanCallContractCall{Call: call}
}

// MockIEthermanCallContractCall wrap *gomock.Call
type MockIEthermanCallContractCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanCallContractCall) Return(arg0 []byte, arg1 error) *MockIEthermanCallContractCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanCallContractCall) Do(f func(context.Context, ethereum.CallMsg, *big.Int) ([]byte, error)) *MockIEthermanCallContractCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanCallContractCall) DoAndReturn(f func(context.Context, ethereum.CallMsg, *big.Int) ([]byte, error)) *MockIEthermanCallContractCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FilterLogs mocks base method.
func (m *MockIEtherman) FilterLogs(ctx context.Context, query ethereum.FilterQuery) ([]types.Log, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilterLogs", ctx, query)
	ret0, _ := ret[0].([]types.Log)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FilterLogs indicates an expected call of FilterLogs.
func (mr *MockIEthermanMockRecorder) FilterLogs(ctx, query any) *MockIEthermanFilterLogsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilterLogs", reflect.TypeOf((*MockIEtherman)(nil).FilterLogs), ctx, query)
	return &MockIEthermanFilterLogsCall{Call: call}
}

// MockIEthermanFilterLogsCall wrap *gomock.Call
type MockIEthermanFilterLogsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanFilterLogsCall) Return(arg0 []types.Log, arg1 error) *MockIEthermanFilterLogsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanFilterLogsCall) Do(f func(context.Context, ethereum.FilterQuery) ([]types.Log, error)) *MockIEthermanFilterLogsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanFilterLogsCall) DoAndReturn(f func(context.Context, ethereum.FilterQuery) ([]types.Log, error)) *MockIEthermanFilterLogsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HeaderByNumber mocks base method.
func (m *MockIEtherman) HeaderByNumber(ctx context.Context, blockNumber *big.Int) (*types.Header, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HeaderByNumber", ctx, blockNumber)
	ret0, _ := ret[0].(*types.Header)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HeaderByNumber indicates an expected call of HeaderByNumber.
func (mr *MockIEthermanMockRecorder) HeaderByNumber(ctx, blockNumber any) *MockIEthermanHeaderByNumberCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HeaderByNumber", reflect.TypeOf((*MockIEtherman)(nil).HeaderByNumber), ctx, blockNumber)
	return &MockIEthermanHeaderByNumberCall{Call: call}
}

// MockIEthermanHeaderByNumberCall wrap *gomock.Call
type MockIEthermanHeaderByNumberCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanHeaderByNumberCall) Return(arg0 *types.Header, arg1 error) *MockIEthermanHeaderByNumberCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanHeaderByNumberCall) Do(f func(context.Context, *big.Int) (*types.Header, error)) *MockIEthermanHeaderByNumberCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanHeaderByNumberCall) DoAndReturn(f func(context.Context, *big.Int) (*types.Header, error)) *MockIEthermanHeaderByNumberCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StorageAt mocks base method.
func (m *MockIEtherman) StorageAt(ctx context.Context, account common.Address, key common.Hash, blockNumber *big.Int) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StorageAt", ctx, account, key, blockNumber)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StorageAt indicates an expected call of StorageAt.
func (mr *MockIEthermanMockRecorder) StorageAt(ctx, account, key, blockNumber any) *MockIEthermanStorageAtCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageAt", reflect.TypeOf((*MockIEtherman)(nil).StorageAt), ctx, account, key, blockNumber)
	return &MockIEthermanStorageAtCall{Call: call}
}

// MockIEthermanStorageAtCall wrap *gomock.Call
type MockIEthermanStorageAtCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanStorageAtCall) Return(arg0 []byte, arg1 error) *MockIEthermanStorageAtCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanStorageAtCall) Do(f func(context.Context, common.Address, common.Hash, *big.Int) ([]byte, error)) *MockIEthermanStorageAtCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanStorageAtCall) DoAndReturn(f func(context.Context, common.Address, common.Hash, *big.Int) ([]byte, error)) *MockIEthermanStorageAtCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TransactionByHash mocks base method.
func (m *MockIEtherman) TransactionByHash(ctx context.Context, hash common.Hash) (types.Transaction, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TransactionByHash", ctx, hash)
	ret0, _ := ret[0].(types.Transaction)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// TransactionByHash indicates an expected call of TransactionByHash.
func (mr *MockIEthermanMockRecorder) TransactionByHash(ctx, hash any) *MockIEthermanTransactionByHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransactionByHash", reflect.TypeOf((*MockIEtherman)(nil).TransactionByHash), ctx, hash)
	return &MockIEthermanTransactionByHashCall{Call: call}
}

// MockIEthermanTransactionByHashCall wrap *gomock.Call
type MockIEthermanTransactionByHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanTransactionByHashCall) Return(arg0 types.Transaction, arg1 bool, arg2 error) *MockIEthermanTransactionByHashCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanTransactionByHashCall) Do(f func(context.Context, common.Hash) (types.Transaction, bool, error)) *MockIEthermanTransactionByHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanTransactionByHashCall) DoAndReturn(f func(context.Context, common.Hash) (types.Transaction, bool, error)) *MockIEthermanTransactionByHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TransactionReceipt mocks base method.
func (m *MockIEtherman) TransactionReceipt(ctx context.Context, txHash common.Hash) (*types.Receipt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TransactionReceipt", ctx, txHash)
	ret0, _ := ret[0].(*types.Receipt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TransactionReceipt indicates an expected call of TransactionReceipt.
func (mr *MockIEthermanMockRecorder) TransactionReceipt(ctx, txHash any) *MockIEthermanTransactionReceiptCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransactionReceipt", reflect.TypeOf((*MockIEtherman)(nil).TransactionReceipt), ctx, txHash)
	return &MockIEthermanTransactionReceiptCall{Call: call}
}

// MockIEthermanTransactionReceiptCall wrap *gomock.Call
type MockIEthermanTransactionReceiptCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanTransactionReceiptCall) Return(arg0 *types.Receipt, arg1 error) *MockIEthermanTransactionReceiptCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanTransactionReceiptCall) Do(f func(context.Context, common.Hash) (*types.Receipt, error)) *MockIEthermanTransactionReceiptCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanTransactionReceiptCall) DoAndReturn(f func(context.Context, common.Hash) (*types.Receipt, error)) *MockIEthermanTransactionReceiptCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
