// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/erigontech/erigon/consensus (interfaces: Engine)
//
// Generated by this command:
//
//	mockgen -typed=true -destination=./engine_mock.go -package=consensus . Engine
//

// Package consensus is a generated GoMock package.
package consensus

import (
	big "math/big"
	reflect "reflect"

	chain "github.com/erigontech/erigon-lib/chain"
	common "github.com/erigontech/erigon-lib/common"
	log "github.com/erigontech/erigon-lib/log/v3"
	state "github.com/erigontech/erigon/core/state"
	types "github.com/erigontech/erigon/core/types"
	evmtypes "github.com/erigontech/erigon/core/vm/evmtypes"
	rpc "github.com/erigontech/erigon/rpc"
	gomock "go.uber.org/mock/gomock"
)

// MockEngine is a mock of Engine interface.
type MockEngine struct {
	ctrl     *gomock.Controller
	recorder *MockEngineMockRecorder
	isgomock struct{}
}

// MockEngineMockRecorder is the mock recorder for MockEngine.
type MockEngineMockRecorder struct {
	mock *MockEngine
}

// NewMockEngine creates a new mock instance.
func NewMockEngine(ctrl *gomock.Controller) *MockEngine {
	mock := &MockEngine{ctrl: ctrl}
	mock.recorder = &MockEngineMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEngine) EXPECT() *MockEngineMockRecorder {
	return m.recorder
}

// APIs mocks base method.
func (m *MockEngine) APIs(chain ChainHeaderReader) []rpc.API {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "APIs", chain)
	ret0, _ := ret[0].([]rpc.API)
	return ret0
}

// APIs indicates an expected call of APIs.
func (mr *MockEngineMockRecorder) APIs(chain any) *MockEngineAPIsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "APIs", reflect.TypeOf((*MockEngine)(nil).APIs), chain)
	return &MockEngineAPIsCall{Call: call}
}

// MockEngineAPIsCall wrap *gomock.Call
type MockEngineAPIsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineAPIsCall) Return(arg0 []rpc.API) *MockEngineAPIsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineAPIsCall) Do(f func(ChainHeaderReader) []rpc.API) *MockEngineAPIsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineAPIsCall) DoAndReturn(f func(ChainHeaderReader) []rpc.API) *MockEngineAPIsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Author mocks base method.
func (m *MockEngine) Author(header *types.Header) (common.Address, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Author", header)
	ret0, _ := ret[0].(common.Address)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Author indicates an expected call of Author.
func (mr *MockEngineMockRecorder) Author(header any) *MockEngineAuthorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Author", reflect.TypeOf((*MockEngine)(nil).Author), header)
	return &MockEngineAuthorCall{Call: call}
}

// MockEngineAuthorCall wrap *gomock.Call
type MockEngineAuthorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineAuthorCall) Return(arg0 common.Address, arg1 error) *MockEngineAuthorCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineAuthorCall) Do(f func(*types.Header) (common.Address, error)) *MockEngineAuthorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineAuthorCall) DoAndReturn(f func(*types.Header) (common.Address, error)) *MockEngineAuthorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CalcDifficulty mocks base method.
func (m *MockEngine) CalcDifficulty(chain ChainHeaderReader, time, parentTime uint64, parentDifficulty *big.Int, parentNumber uint64, parentHash, parentUncleHash common.Hash, parentAuRaStep uint64) *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalcDifficulty", chain, time, parentTime, parentDifficulty, parentNumber, parentHash, parentUncleHash, parentAuRaStep)
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// CalcDifficulty indicates an expected call of CalcDifficulty.
func (mr *MockEngineMockRecorder) CalcDifficulty(chain, time, parentTime, parentDifficulty, parentNumber, parentHash, parentUncleHash, parentAuRaStep any) *MockEngineCalcDifficultyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalcDifficulty", reflect.TypeOf((*MockEngine)(nil).CalcDifficulty), chain, time, parentTime, parentDifficulty, parentNumber, parentHash, parentUncleHash, parentAuRaStep)
	return &MockEngineCalcDifficultyCall{Call: call}
}

// MockEngineCalcDifficultyCall wrap *gomock.Call
type MockEngineCalcDifficultyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineCalcDifficultyCall) Return(arg0 *big.Int) *MockEngineCalcDifficultyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineCalcDifficultyCall) Do(f func(ChainHeaderReader, uint64, uint64, *big.Int, uint64, common.Hash, common.Hash, uint64) *big.Int) *MockEngineCalcDifficultyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineCalcDifficultyCall) DoAndReturn(f func(ChainHeaderReader, uint64, uint64, *big.Int, uint64, common.Hash, common.Hash, uint64) *big.Int) *MockEngineCalcDifficultyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CalculateRewards mocks base method.
func (m *MockEngine) CalculateRewards(config *chain.Config, header *types.Header, uncles []*types.Header, syscall SystemCall) ([]Reward, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalculateRewards", config, header, uncles, syscall)
	ret0, _ := ret[0].([]Reward)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalculateRewards indicates an expected call of CalculateRewards.
func (mr *MockEngineMockRecorder) CalculateRewards(config, header, uncles, syscall any) *MockEngineCalculateRewardsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalculateRewards", reflect.TypeOf((*MockEngine)(nil).CalculateRewards), config, header, uncles, syscall)
	return &MockEngineCalculateRewardsCall{Call: call}
}

// MockEngineCalculateRewardsCall wrap *gomock.Call
type MockEngineCalculateRewardsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineCalculateRewardsCall) Return(arg0 []Reward, arg1 error) *MockEngineCalculateRewardsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineCalculateRewardsCall) Do(f func(*chain.Config, *types.Header, []*types.Header, SystemCall) ([]Reward, error)) *MockEngineCalculateRewardsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineCalculateRewardsCall) DoAndReturn(f func(*chain.Config, *types.Header, []*types.Header, SystemCall) ([]Reward, error)) *MockEngineCalculateRewardsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockEngine) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEngineMockRecorder) Close() *MockEngineCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEngine)(nil).Close))
	return &MockEngineCloseCall{Call: call}
}

// MockEngineCloseCall wrap *gomock.Call
type MockEngineCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineCloseCall) Return(arg0 error) *MockEngineCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineCloseCall) Do(f func() error) *MockEngineCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineCloseCall) DoAndReturn(f func() error) *MockEngineCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Finalize mocks base method.
func (m *MockEngine) Finalize(config *chain.Config, header *types.Header, state *state.IntraBlockState, txs types.Transactions, uncles []*types.Header, receipts types.Receipts, withdrawals []*types.Withdrawal, chain ChainReader, syscall SystemCall, logger log.Logger) (types.Transactions, types.Receipts, types.FlatRequests, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Finalize", config, header, state, txs, uncles, receipts, withdrawals, chain, syscall, logger)
	ret0, _ := ret[0].(types.Transactions)
	ret1, _ := ret[1].(types.Receipts)
	ret2, _ := ret[2].(types.FlatRequests)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// Finalize indicates an expected call of Finalize.
func (mr *MockEngineMockRecorder) Finalize(config, header, state, txs, uncles, receipts, withdrawals, chain, syscall, logger any) *MockEngineFinalizeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Finalize", reflect.TypeOf((*MockEngine)(nil).Finalize), config, header, state, txs, uncles, receipts, withdrawals, chain, syscall, logger)
	return &MockEngineFinalizeCall{Call: call}
}

// MockEngineFinalizeCall wrap *gomock.Call
type MockEngineFinalizeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineFinalizeCall) Return(arg0 types.Transactions, arg1 types.Receipts, arg2 types.FlatRequests, arg3 error) *MockEngineFinalizeCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineFinalizeCall) Do(f func(*chain.Config, *types.Header, *state.IntraBlockState, types.Transactions, []*types.Header, types.Receipts, []*types.Withdrawal, ChainReader, SystemCall, log.Logger) (types.Transactions, types.Receipts, types.FlatRequests, error)) *MockEngineFinalizeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineFinalizeCall) DoAndReturn(f func(*chain.Config, *types.Header, *state.IntraBlockState, types.Transactions, []*types.Header, types.Receipts, []*types.Withdrawal, ChainReader, SystemCall, log.Logger) (types.Transactions, types.Receipts, types.FlatRequests, error)) *MockEngineFinalizeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FinalizeAndAssemble mocks base method.
func (m *MockEngine) FinalizeAndAssemble(config *chain.Config, header *types.Header, state *state.IntraBlockState, txs types.Transactions, uncles []*types.Header, receipts types.Receipts, withdrawals []*types.Withdrawal, chain ChainReader, syscall SystemCall, call1 Call, logger log.Logger) (*types.Block, types.Transactions, types.Receipts, types.FlatRequests, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FinalizeAndAssemble", config, header, state, txs, uncles, receipts, withdrawals, chain, syscall, call1, logger)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(types.Transactions)
	ret2, _ := ret[2].(types.Receipts)
	ret3, _ := ret[3].(types.FlatRequests)
	ret4, _ := ret[4].(error)
	return ret0, ret1, ret2, ret3, ret4
}

// FinalizeAndAssemble indicates an expected call of FinalizeAndAssemble.
func (mr *MockEngineMockRecorder) FinalizeAndAssemble(config, header, state, txs, uncles, receipts, withdrawals, chain, syscall, call1, logger any) *MockEngineFinalizeAndAssembleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FinalizeAndAssemble", reflect.TypeOf((*MockEngine)(nil).FinalizeAndAssemble), config, header, state, txs, uncles, receipts, withdrawals, chain, syscall, call1, logger)
	return &MockEngineFinalizeAndAssembleCall{Call: call}
}

// MockEngineFinalizeAndAssembleCall wrap *gomock.Call
type MockEngineFinalizeAndAssembleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineFinalizeAndAssembleCall) Return(arg0 *types.Block, arg1 types.Transactions, arg2 types.Receipts, arg3 types.FlatRequests, arg4 error) *MockEngineFinalizeAndAssembleCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3, arg4)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineFinalizeAndAssembleCall) Do(f func(*chain.Config, *types.Header, *state.IntraBlockState, types.Transactions, []*types.Header, types.Receipts, []*types.Withdrawal, ChainReader, SystemCall, Call, log.Logger) (*types.Block, types.Transactions, types.Receipts, types.FlatRequests, error)) *MockEngineFinalizeAndAssembleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineFinalizeAndAssembleCall) DoAndReturn(f func(*chain.Config, *types.Header, *state.IntraBlockState, types.Transactions, []*types.Header, types.Receipts, []*types.Withdrawal, ChainReader, SystemCall, Call, log.Logger) (*types.Block, types.Transactions, types.Receipts, types.FlatRequests, error)) *MockEngineFinalizeAndAssembleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GenerateSeal mocks base method.
func (m *MockEngine) GenerateSeal(chain ChainHeaderReader, currnt, parent *types.Header, call1 Call) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateSeal", chain, currnt, parent, call1)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GenerateSeal indicates an expected call of GenerateSeal.
func (mr *MockEngineMockRecorder) GenerateSeal(chain, currnt, parent, call1 any) *MockEngineGenerateSealCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateSeal", reflect.TypeOf((*MockEngine)(nil).GenerateSeal), chain, currnt, parent, call1)
	return &MockEngineGenerateSealCall{Call: call}
}

// MockEngineGenerateSealCall wrap *gomock.Call
type MockEngineGenerateSealCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineGenerateSealCall) Return(arg0 []byte) *MockEngineGenerateSealCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineGenerateSealCall) Do(f func(ChainHeaderReader, *types.Header, *types.Header, Call) []byte) *MockEngineGenerateSealCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineGenerateSealCall) DoAndReturn(f func(ChainHeaderReader, *types.Header, *types.Header, Call) []byte) *MockEngineGenerateSealCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPostApplyMessageFunc mocks base method.
func (m *MockEngine) GetPostApplyMessageFunc() evmtypes.PostApplyMessageFunc {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPostApplyMessageFunc")
	ret0, _ := ret[0].(evmtypes.PostApplyMessageFunc)
	return ret0
}

// GetPostApplyMessageFunc indicates an expected call of GetPostApplyMessageFunc.
func (mr *MockEngineMockRecorder) GetPostApplyMessageFunc() *MockEngineGetPostApplyMessageFuncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPostApplyMessageFunc", reflect.TypeOf((*MockEngine)(nil).GetPostApplyMessageFunc))
	return &MockEngineGetPostApplyMessageFuncCall{Call: call}
}

// MockEngineGetPostApplyMessageFuncCall wrap *gomock.Call
type MockEngineGetPostApplyMessageFuncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineGetPostApplyMessageFuncCall) Return(arg0 evmtypes.PostApplyMessageFunc) *MockEngineGetPostApplyMessageFuncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineGetPostApplyMessageFuncCall) Do(f func() evmtypes.PostApplyMessageFunc) *MockEngineGetPostApplyMessageFuncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineGetPostApplyMessageFuncCall) DoAndReturn(f func() evmtypes.PostApplyMessageFunc) *MockEngineGetPostApplyMessageFuncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransferFunc mocks base method.
func (m *MockEngine) GetTransferFunc() evmtypes.TransferFunc {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransferFunc")
	ret0, _ := ret[0].(evmtypes.TransferFunc)
	return ret0
}

// GetTransferFunc indicates an expected call of GetTransferFunc.
func (mr *MockEngineMockRecorder) GetTransferFunc() *MockEngineGetTransferFuncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransferFunc", reflect.TypeOf((*MockEngine)(nil).GetTransferFunc))
	return &MockEngineGetTransferFuncCall{Call: call}
}

// MockEngineGetTransferFuncCall wrap *gomock.Call
type MockEngineGetTransferFuncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineGetTransferFuncCall) Return(arg0 evmtypes.TransferFunc) *MockEngineGetTransferFuncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineGetTransferFuncCall) Do(f func() evmtypes.TransferFunc) *MockEngineGetTransferFuncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineGetTransferFuncCall) DoAndReturn(f func() evmtypes.TransferFunc) *MockEngineGetTransferFuncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Initialize mocks base method.
func (m *MockEngine) Initialize(config *chain.Config, chain ChainHeaderReader, header *types.Header, state *state.IntraBlockState, syscall SysCallCustom, logger log.Logger) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Initialize", config, chain, header, state, syscall, logger)
}

// Initialize indicates an expected call of Initialize.
func (mr *MockEngineMockRecorder) Initialize(config, chain, header, state, syscall, logger any) *MockEngineInitializeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Initialize", reflect.TypeOf((*MockEngine)(nil).Initialize), config, chain, header, state, syscall, logger)
	return &MockEngineInitializeCall{Call: call}
}

// MockEngineInitializeCall wrap *gomock.Call
type MockEngineInitializeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineInitializeCall) Return() *MockEngineInitializeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineInitializeCall) Do(f func(*chain.Config, ChainHeaderReader, *types.Header, *state.IntraBlockState, SysCallCustom, log.Logger)) *MockEngineInitializeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineInitializeCall) DoAndReturn(f func(*chain.Config, ChainHeaderReader, *types.Header, *state.IntraBlockState, SysCallCustom, log.Logger)) *MockEngineInitializeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsServiceTransaction mocks base method.
func (m *MockEngine) IsServiceTransaction(sender common.Address, syscall SystemCall) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsServiceTransaction", sender, syscall)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsServiceTransaction indicates an expected call of IsServiceTransaction.
func (mr *MockEngineMockRecorder) IsServiceTransaction(sender, syscall any) *MockEngineIsServiceTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsServiceTransaction", reflect.TypeOf((*MockEngine)(nil).IsServiceTransaction), sender, syscall)
	return &MockEngineIsServiceTransactionCall{Call: call}
}

// MockEngineIsServiceTransactionCall wrap *gomock.Call
type MockEngineIsServiceTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineIsServiceTransactionCall) Return(arg0 bool) *MockEngineIsServiceTransactionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineIsServiceTransactionCall) Do(f func(common.Address, SystemCall) bool) *MockEngineIsServiceTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineIsServiceTransactionCall) DoAndReturn(f func(common.Address, SystemCall) bool) *MockEngineIsServiceTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Prepare mocks base method.
func (m *MockEngine) Prepare(chain ChainHeaderReader, header *types.Header, state *state.IntraBlockState) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare", chain, header, state)
	ret0, _ := ret[0].(error)
	return ret0
}

// Prepare indicates an expected call of Prepare.
func (mr *MockEngineMockRecorder) Prepare(chain, header, state any) *MockEnginePrepareCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockEngine)(nil).Prepare), chain, header, state)
	return &MockEnginePrepareCall{Call: call}
}

// MockEnginePrepareCall wrap *gomock.Call
type MockEnginePrepareCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEnginePrepareCall) Return(arg0 error) *MockEnginePrepareCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEnginePrepareCall) Do(f func(ChainHeaderReader, *types.Header, *state.IntraBlockState) error) *MockEnginePrepareCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEnginePrepareCall) DoAndReturn(f func(ChainHeaderReader, *types.Header, *state.IntraBlockState) error) *MockEnginePrepareCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Seal mocks base method.
func (m *MockEngine) Seal(chain ChainHeaderReader, block *types.BlockWithReceipts, results chan<- *types.BlockWithReceipts, stop <-chan struct{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Seal", chain, block, results, stop)
	ret0, _ := ret[0].(error)
	return ret0
}

// Seal indicates an expected call of Seal.
func (mr *MockEngineMockRecorder) Seal(chain, block, results, stop any) *MockEngineSealCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Seal", reflect.TypeOf((*MockEngine)(nil).Seal), chain, block, results, stop)
	return &MockEngineSealCall{Call: call}
}

// MockEngineSealCall wrap *gomock.Call
type MockEngineSealCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineSealCall) Return(arg0 error) *MockEngineSealCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineSealCall) Do(f func(ChainHeaderReader, *types.BlockWithReceipts, chan<- *types.BlockWithReceipts, <-chan struct{}) error) *MockEngineSealCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineSealCall) DoAndReturn(f func(ChainHeaderReader, *types.BlockWithReceipts, chan<- *types.BlockWithReceipts, <-chan struct{}) error) *MockEngineSealCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SealHash mocks base method.
func (m *MockEngine) SealHash(header *types.Header) common.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SealHash", header)
	ret0, _ := ret[0].(common.Hash)
	return ret0
}

// SealHash indicates an expected call of SealHash.
func (mr *MockEngineMockRecorder) SealHash(header any) *MockEngineSealHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SealHash", reflect.TypeOf((*MockEngine)(nil).SealHash), header)
	return &MockEngineSealHashCall{Call: call}
}

// MockEngineSealHashCall wrap *gomock.Call
type MockEngineSealHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineSealHashCall) Return(arg0 common.Hash) *MockEngineSealHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineSealHashCall) Do(f func(*types.Header) common.Hash) *MockEngineSealHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineSealHashCall) DoAndReturn(f func(*types.Header) common.Hash) *MockEngineSealHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Type mocks base method.
func (m *MockEngine) Type() chain.ConsensusName {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(chain.ConsensusName)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockEngineMockRecorder) Type() *MockEngineTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockEngine)(nil).Type))
	return &MockEngineTypeCall{Call: call}
}

// MockEngineTypeCall wrap *gomock.Call
type MockEngineTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineTypeCall) Return(arg0 chain.ConsensusName) *MockEngineTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineTypeCall) Do(f func() chain.ConsensusName) *MockEngineTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineTypeCall) DoAndReturn(f func() chain.ConsensusName) *MockEngineTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VerifyHeader mocks base method.
func (m *MockEngine) VerifyHeader(chain ChainHeaderReader, header *types.Header, seal bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyHeader", chain, header, seal)
	ret0, _ := ret[0].(error)
	return ret0
}

// VerifyHeader indicates an expected call of VerifyHeader.
func (mr *MockEngineMockRecorder) VerifyHeader(chain, header, seal any) *MockEngineVerifyHeaderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyHeader", reflect.TypeOf((*MockEngine)(nil).VerifyHeader), chain, header, seal)
	return &MockEngineVerifyHeaderCall{Call: call}
}

// MockEngineVerifyHeaderCall wrap *gomock.Call
type MockEngineVerifyHeaderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineVerifyHeaderCall) Return(arg0 error) *MockEngineVerifyHeaderCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineVerifyHeaderCall) Do(f func(ChainHeaderReader, *types.Header, bool) error) *MockEngineVerifyHeaderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineVerifyHeaderCall) DoAndReturn(f func(ChainHeaderReader, *types.Header, bool) error) *MockEngineVerifyHeaderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VerifyUncles mocks base method.
func (m *MockEngine) VerifyUncles(chain ChainReader, header *types.Header, uncles []*types.Header) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyUncles", chain, header, uncles)
	ret0, _ := ret[0].(error)
	return ret0
}

// VerifyUncles indicates an expected call of VerifyUncles.
func (mr *MockEngineMockRecorder) VerifyUncles(chain, header, uncles any) *MockEngineVerifyUnclesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyUncles", reflect.TypeOf((*MockEngine)(nil).VerifyUncles), chain, header, uncles)
	return &MockEngineVerifyUnclesCall{Call: call}
}

// MockEngineVerifyUnclesCall wrap *gomock.Call
type MockEngineVerifyUnclesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEngineVerifyUnclesCall) Return(arg0 error) *MockEngineVerifyUnclesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEngineVerifyUnclesCall) Do(f func(ChainReader, *types.Header, []*types.Header) error) *MockEngineVerifyUnclesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEngineVerifyUnclesCall) DoAndReturn(f func(ChainReader, *types.Header, []*types.Header) error) *MockEngineVerifyUnclesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
